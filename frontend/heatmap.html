<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xG Heatmap Visualization</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            margin-bottom: 1rem;
            color: #333;
        }

        .controls {
            margin-bottom: 1.5rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-group label {
            font-weight: 500;
            color: #333;
        }

        .control-group select {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            font-size: 0.9rem;
        }

        .control-group button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .control-group button:hover {
            background-color: #0056b3;
        }

        .control-group button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #pitch-container {
            width: 100%;
            max-width: 1000px;
            margin: 1rem auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            background-color: transparent;
        }

        .legend {
            margin-top: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        .legend-gradient {
            width: 200px;
            height: 20px;
            background: linear-gradient(to right, 
                rgba(0, 0, 255, 0.1), 
                rgba(0, 255, 0, 0.3), 
                rgba(255, 255, 0, 0.5), 
                rgba(255, 165, 0, 0.7), 
                rgba(255, 0, 0, 0.9));
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            width: 200px;
            font-size: 0.8rem;
            margin-top: 0.25rem;
        }

        .status {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-weight: 500;
            text-align: center;
        }

        .status.loading {
            background-color: #fff3cd;
            color: #856404;
        }

        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }

        .status.success {
            background-color: #d4edda;
            color: #155724;
        }
    </style>
</head>
<body>
    <h1>xG Heatmap Visualization</h1>

    <div class="controls">
        <div class="control-group">
            <label for="situation-select">Situation:</label>
            <select id="situation-select">
                <option value="">All Situations</option>
                <option value="OpenPlay">Open Play</option>
                <option value="SetPiece">Set Piece</option>
                <option value="DirectFreekick">Direct Free Kick</option>
                <option value="FromCorner">From Corner</option>
            </select>
        </div>
        <div class="control-group">
            <label for="shot-type-select">Shot Type:</label>
            <select id="shot-type-select">
                <option value="">All Shot Types</option>
                <option value="Head">Head</option>
                <option value="RightFoot">Right Foot</option>
                <option value="LeftFoot">Left Foot</option>
                <option value="OtherBodyPart">Other Body Part</option>
            </select>
        </div>
        <div class="control-group">
            <button id="load-heatmap">Load Heatmap</button>
        </div>
    </div>

    <div id="pitch-container">
        <canvas id="football-pitch"></canvas>
    </div>

    <div class="legend">
        <div class="legend-item">
            <span>xG Value:</span>
            <div>
                <div class="legend-gradient"></div>
                <div class="legend-labels">
                    <span>0.0</span>
                    <span>0.2</span>
                    <span>0.4</span>
                    <span>0.6</span>
                    <span>0.8</span>
                    <span>1.0</span>
                </div>
            </div>
        </div>
    </div>

    <div id="status" class="status" style="display: none;"></div>

    <script>
        // DOM elements
        const canvas = document.getElementById('football-pitch');
        const ctx = canvas.getContext('2d');
        const pitchContainer = document.getElementById('pitch-container');
        const statusDiv = document.getElementById('status');
        const loadButton = document.getElementById('load-heatmap');

        // Pitch dimensions (FIFA Standard)
        const PITCH_LENGTH_METERS = 105;
        const PITCH_WIDTH_METERS = 68;
        const GOAL_WIDTH_METERS = 7.32;
        const GOAL_DEPTH_METERS = 2;
        const PADDING_METERS = 3;
        const TOTAL_WIDTH_METERS = PITCH_LENGTH_METERS + 2 * PADDING_METERS;
        const ASPECT_RATIO = TOTAL_WIDTH_METERS / PITCH_WIDTH_METERS;

        // Pitch markings
        const GOAL_AREA_LENGTH = 5.5;
        const GOAL_AREA_WIDTH = 18.32;
        const PENALTY_AREA_LENGTH = 16.5;
        const PENALTY_AREA_WIDTH = 40.32;
        const CENTER_CIRCLE_RADIUS = 9.15;
        const PENALTY_SPOT_DISTANCE = 11;

        // State
        let scale;
        let heatmapData = null;
        const LINE_COLOR = '#000080';

        // Color mapping for xG values - returns RGBA object
        function getHeatmapColorRGBA(xgValue) {
            if (xgValue === 0) return { r: 0, g: 0, b: 0, a: 0 };
            
            // Normalize xG value (0-1) to color intensity
            const intensity = Math.min(xgValue, 1);
            
            // Create color gradient: blue -> green -> yellow -> orange -> red
            let r, g, b;
            
            if (intensity <= 0.2) {
                // Blue to green
                const t = intensity / 0.2;
                r = 0;
                g = Math.floor(255 * t);
                b = Math.floor(255 * (1 - t));
            } else if (intensity <= 0.4) {
                // Green to yellow
                const t = (intensity - 0.2) / 0.2;
                r = Math.floor(255 * t);
                g = 255;
                b = 0;
            } else if (intensity <= 0.6) {
                // Yellow to orange
                const t = (intensity - 0.4) / 0.2;
                r = 255;
                g = Math.floor(255 * (1 - t * 0.35));
                b = 0;
            } else if (intensity <= 0.8) {
                // Orange to red
                const t = (intensity - 0.6) / 0.2;
                r = 255;
                g = Math.floor(165 * (1 - t));
                b = 0;
            } else {
                // Red (high intensity)
                r = 255;
                g = 0;
                b = 0;
            }
            
            // Adjust alpha based on intensity
            const alpha = Math.floor(Math.max(25, intensity * 230)); // 25-230 range for better visibility
            
            return { r, g, b, a: alpha };
        }

        // Color mapping for xG values - returns CSS color string (kept for legend)
        function getHeatmapColor(xgValue) {
            const color = getHeatmapColorRGBA(xgValue);
            return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a / 255})`;
        }

        function metersToPixels(metersX, metersY) {
            const px = (metersX + PADDING_METERS) * scale;
            const py = (PITCH_WIDTH_METERS - metersY) * scale;
            return { x: px, y: py };
        }

        function drawLine(x1m, y1m, x2m, y2m) {
            const p1 = metersToPixels(x1m, y1m);
            const p2 = metersToPixels(x2m, y2m);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        function drawCircle(x_m, y_m, radius_m, fill = false, startAngle = 0, endAngle = 2 * Math.PI, anticlockwise = false) {
            const p = metersToPixels(x_m, y_m);
            const radius_px = radius_m * scale;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius_px, startAngle, endAngle, anticlockwise);
            if (fill) {
                ctx.fill();
            } else {
                ctx.stroke();
            }
        }

        function drawPitchMarkings() {
            ctx.strokeStyle = LINE_COLOR;
            ctx.fillStyle = LINE_COLOR;
            ctx.lineWidth = 2;

            // Goals
            const goalY1 = (PITCH_WIDTH_METERS - GOAL_WIDTH_METERS) / 2;
            const goalY2 = (PITCH_WIDTH_METERS + GOAL_WIDTH_METERS) / 2;

            // Left Goal
            drawLine(0, goalY1, -GOAL_DEPTH_METERS, goalY1);
            drawLine(0, goalY2, -GOAL_DEPTH_METERS, goalY2);
            drawLine(-GOAL_DEPTH_METERS, goalY1, -GOAL_DEPTH_METERS, goalY2);

            // Right Goal
            drawLine(PITCH_LENGTH_METERS, goalY1, PITCH_LENGTH_METERS + GOAL_DEPTH_METERS, goalY1);
            drawLine(PITCH_LENGTH_METERS, goalY2, PITCH_LENGTH_METERS + GOAL_DEPTH_METERS, goalY2);
            drawLine(PITCH_LENGTH_METERS + GOAL_DEPTH_METERS, goalY1, PITCH_LENGTH_METERS + GOAL_DEPTH_METERS, goalY2);

            // Pitch boundary
            drawLine(0, 0, PITCH_LENGTH_METERS, 0);
            drawLine(0, PITCH_WIDTH_METERS, PITCH_LENGTH_METERS, PITCH_WIDTH_METERS);
            drawLine(0, 0, 0, PITCH_WIDTH_METERS);
            drawLine(PITCH_LENGTH_METERS, 0, PITCH_LENGTH_METERS, PITCH_WIDTH_METERS);

            // Halfway line
            drawLine(PITCH_LENGTH_METERS / 2, 0, PITCH_LENGTH_METERS / 2, PITCH_WIDTH_METERS);

            // Center circle and spot
            drawCircle(PITCH_LENGTH_METERS / 2, PITCH_WIDTH_METERS / 2, CENTER_CIRCLE_RADIUS);
            drawCircle(PITCH_LENGTH_METERS / 2, PITCH_WIDTH_METERS / 2, 0.3, true);

            // Left side markings
            drawLine(0, (PITCH_WIDTH_METERS - PENALTY_AREA_WIDTH) / 2, PENALTY_AREA_LENGTH, (PITCH_WIDTH_METERS - PENALTY_AREA_WIDTH) / 2);
            drawLine(0, (PITCH_WIDTH_METERS + PENALTY_AREA_WIDTH) / 2, PENALTY_AREA_LENGTH, (PITCH_WIDTH_METERS + PENALTY_AREA_WIDTH) / 2);
            drawLine(PENALTY_AREA_LENGTH, (PITCH_WIDTH_METERS - PENALTY_AREA_WIDTH) / 2, PENALTY_AREA_LENGTH, (PITCH_WIDTH_METERS + PENALTY_AREA_WIDTH) / 2);
            
            drawLine(0, (PITCH_WIDTH_METERS - GOAL_AREA_WIDTH) / 2, GOAL_AREA_LENGTH, (PITCH_WIDTH_METERS - GOAL_AREA_WIDTH) / 2);
            drawLine(0, (PITCH_WIDTH_METERS + GOAL_AREA_WIDTH) / 2, GOAL_AREA_LENGTH, (PITCH_WIDTH_METERS + GOAL_AREA_WIDTH) / 2);
            drawLine(GOAL_AREA_LENGTH, (PITCH_WIDTH_METERS - GOAL_AREA_WIDTH) / 2, GOAL_AREA_LENGTH, (PITCH_WIDTH_METERS + GOAL_AREA_WIDTH) / 2);
            
            drawCircle(PENALTY_SPOT_DISTANCE, PITCH_WIDTH_METERS / 2, 0.3, true);
            
            const leftArcAngle = Math.acos((PENALTY_AREA_LENGTH - PENALTY_SPOT_DISTANCE) / CENTER_CIRCLE_RADIUS);
            drawCircle(PENALTY_SPOT_DISTANCE, PITCH_WIDTH_METERS / 2, CENTER_CIRCLE_RADIUS, false, -leftArcAngle, leftArcAngle);

            // Right side markings
            const rightPenaltySpotX = PITCH_LENGTH_METERS - PENALTY_SPOT_DISTANCE;
            
            drawLine(PITCH_LENGTH_METERS, (PITCH_WIDTH_METERS - PENALTY_AREA_WIDTH) / 2, PITCH_LENGTH_METERS - PENALTY_AREA_LENGTH, (PITCH_WIDTH_METERS - PENALTY_AREA_WIDTH) / 2);
            drawLine(PITCH_LENGTH_METERS, (PITCH_WIDTH_METERS + PENALTY_AREA_WIDTH) / 2, PITCH_LENGTH_METERS - PENALTY_AREA_LENGTH, (PITCH_WIDTH_METERS + PENALTY_AREA_WIDTH) / 2);
            drawLine(PITCH_LENGTH_METERS - PENALTY_AREA_LENGTH, (PITCH_WIDTH_METERS - PENALTY_AREA_WIDTH) / 2, PITCH_LENGTH_METERS - PENALTY_AREA_LENGTH, (PITCH_WIDTH_METERS + PENALTY_AREA_WIDTH) / 2);
            
            drawLine(PITCH_LENGTH_METERS, (PITCH_WIDTH_METERS - GOAL_AREA_WIDTH) / 2, PITCH_LENGTH_METERS - GOAL_AREA_LENGTH, (PITCH_WIDTH_METERS - GOAL_AREA_WIDTH) / 2);
            drawLine(PITCH_LENGTH_METERS, (PITCH_WIDTH_METERS + GOAL_AREA_WIDTH) / 2, PITCH_LENGTH_METERS - GOAL_AREA_LENGTH, (PITCH_WIDTH_METERS + GOAL_AREA_WIDTH) / 2);
            drawLine(PITCH_LENGTH_METERS - GOAL_AREA_LENGTH, (PITCH_WIDTH_METERS - GOAL_AREA_WIDTH) / 2, PITCH_LENGTH_METERS - GOAL_AREA_LENGTH, (PITCH_WIDTH_METERS + GOAL_AREA_WIDTH) / 2);

            drawCircle(rightPenaltySpotX, PITCH_WIDTH_METERS / 2, 0.3, true);
            
            const rightArcAngle = Math.acos((rightPenaltySpotX - (PITCH_LENGTH_METERS - PENALTY_AREA_LENGTH)) / CENTER_CIRCLE_RADIUS);
            drawCircle(rightPenaltySpotX, PITCH_WIDTH_METERS / 2, CENTER_CIRCLE_RADIUS, false, Math.PI - rightArcAngle, Math.PI + rightArcAngle, false);
        }

        function drawHeatmap() {
            if (!heatmapData) return;

            const xCoords = heatmapData.grid_definition.x_coords;
            const yCoords = heatmapData.grid_definition.y_coords;
            const heatmap = heatmapData.heatmap;

            // Calculate grid cell size in meters
            const cellWidth = xCoords.length > 1 ? xCoords[1] - xCoords[0] : 0.01;
            const cellHeight = yCoords.length > 1 ? yCoords[1] - yCoords[0] : 0.01;

            // Create ImageData for smooth rendering
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            // Fill the image data with heatmap colors
            for (let pixelY = 0; pixelY < canvas.height; pixelY++) {
                for (let pixelX = 0; pixelX < canvas.width; pixelX++) {
                    // Convert pixel coordinates back to meters
                    const meterX = (pixelX / scale) - PADDING_METERS;
                    const meterY = PITCH_WIDTH_METERS - (pixelY / scale);
                    
                    // Only draw within pitch boundaries
                    if (meterX >= 0 && meterX <= PITCH_LENGTH_METERS && 
                        meterY >= 0 && meterY <= PITCH_WIDTH_METERS) {
                        
                        // Find the closest grid point using bilinear interpolation
                        const xIndex = Math.max(0, Math.min(xCoords.length - 1, 
                            Math.floor(meterX / cellWidth)));
                        const yIndex = Math.max(0, Math.min(yCoords.length - 1, 
                            Math.floor(meterY / cellHeight)));
                        
                        let xgValue = 0;
                        
                        // Bilinear interpolation for smoother transitions
                        if (xIndex < xCoords.length - 1 && yIndex < yCoords.length - 1) {
                            const x1 = xCoords[xIndex];
                            const x2 = xCoords[xIndex + 1];
                            const y1 = yCoords[yIndex];
                            const y2 = yCoords[yIndex + 1];
                            
                            const xWeight = (meterX - x1) / (x2 - x1);
                            const yWeight = (meterY - y1) / (y2 - y1);
                            
                            // Get the four surrounding values
                            const v00 = heatmap[yIndex][xIndex] || 0;
                            const v10 = heatmap[yIndex][xIndex + 1] || 0;
                            const v01 = heatmap[yIndex + 1] ? heatmap[yIndex + 1][xIndex] || 0 : 0;
                            const v11 = heatmap[yIndex + 1] ? heatmap[yIndex + 1][xIndex + 1] || 0 : 0;
                            
                            // Bilinear interpolation
                            const top = v00 * (1 - xWeight) + v10 * xWeight;
                            const bottom = v01 * (1 - xWeight) + v11 * xWeight;
                            xgValue = top * (1 - yWeight) + bottom * yWeight;
                        } else {
                            // Fallback to nearest neighbor
                            xgValue = heatmap[yIndex] ? heatmap[yIndex][xIndex] || 0 : 0;
                        }
                        
                        if (xgValue > 0) {
                            const color = getHeatmapColorRGBA(xgValue);
                            const pixelIndex = (pixelY * canvas.width + pixelX) * 4;
                            
                            data[pixelIndex] = color.r;     // Red
                            data[pixelIndex + 1] = color.g; // Green
                            data[pixelIndex + 2] = color.b; // Blue
                            data[pixelIndex + 3] = color.a; // Alpha
                        }
                    }
                }
            }
            
            // Draw the image data to canvas
            ctx.putImageData(imageData, 0, 0);
        }

        function drawComplete() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Enable image smoothing for better quality
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Draw heatmap first (behind the pitch lines)
            drawHeatmap();
            
            // Draw pitch markings on top with slight transparency so heatmap shows through
            ctx.globalAlpha = 0.8;
            drawPitchMarkings();
            ctx.globalAlpha = 1.0; // Reset alpha
        }

        function setupCanvas() {
            const containerWidth = pitchContainer.clientWidth;
            canvas.width = containerWidth;
            canvas.height = containerWidth / ASPECT_RATIO;
            scale = canvas.width / TOTAL_WIDTH_METERS;
            drawComplete();
        }

        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
        }

        function hideStatus() {
            statusDiv.style.display = 'none';
        }

        async function loadHeatmapData() {
            const situation = document.getElementById('situation-select').value || null;
            const shotType = document.getElementById('shot-type-select').value || null;
            
            showStatus('Loading heatmap data...', 'loading');
            loadButton.disabled = true;

            try {
                const params = new URLSearchParams();
                if (situation) params.append('situation', situation);
                if (shotType) params.append('shot_type', shotType);
                params.append('max_length', PITCH_LENGTH_METERS.toString());
                params.append('max_width', PITCH_WIDTH_METERS.toString());

                const response = await fetch(`http://127.0.0.1:5000/api/predict/grid?${params}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                heatmapData = data;
                
                drawComplete();
                showStatus('Heatmap loaded successfully!', 'success');
                setTimeout(hideStatus, 3000);
                
            } catch (error) {
                console.error('Error loading heatmap:', error);
                showStatus('Error loading heatmap data. Please check your backend connection.', 'error');
            } finally {
                loadButton.disabled = false;
            }
        }

        // Event listeners
        window.addEventListener('resize', setupCanvas);
        loadButton.addEventListener('click', loadHeatmapData);

        // Initialize
        window.onload = setupCanvas;
    </script>
</body>
</html>